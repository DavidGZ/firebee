/*
 * exceptions.c
 *
 * This file is part of BaS_gcc.
 *
 * BaS_gcc is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * BaS_gcc is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BaS_gcc.  If not, see <http://www.gnu.org/licenses/>.
 *
 * derived from original BaS assembler sources:
 * Copyright 2010 - 2012 F. Aschwanden
 * Copyright 2013        M. Froeschle
 */

#include <stdint.h>
#include "bas_printf.h"
#include "bas_string.h"
#include "startcf.h"
#include "interrupts.h"
#include "exceptions.h"
#include "MCF5475.h"

#if MACHINE_FIREBEE
#include "firebee.h"
#elif MACHINE_M5484LITE
#include "m5484l.h"
#endif /* MACHINE_FIREBEE */


#define DEBUG_EXC
#ifdef DEBUG_EXC
#define debug_printf(format, arg...) do { xprintf("DEBUG: " format "\r\n", ##arg); } while (0)
#else
#define debug_printf(format, arg...) do { ; } while (0)
#endif /* DEBUG_EXC */

typedef void (*exception_handler)(uint32_t fs, uint32_t vector);

static inline uint32_t set_vbr(uint32_t value)
{
	extern uint32_t rt_vbr;
	uint32_t ret = rt_vbr;

	__asm__ __volatile__(
		"movec		%[value],VBR\n\t"
		: /* no output */
		: [value] "r" (value)
		: /* no clobber */
	);
	rt_vbr = value;

	return ret;
}

static void std_exception_handler(uint32_t fs, uint32_t vector)
{
	register uint32_t d0 asm("d0");
	register uint32_t d1 asm("d1");
	register uint32_t a0 asm("a0");
	register uint32_t a1 asm("a1");

	uint32_t old_ipl;
	extern uint32_t rt_vbr;

	old_ipl = set_ipl(7);

#if MACHINE_FIREBEE
	if (DIP_SWITCH & (1 << 7))
	{
		xprintf("protect mode selected by DIP switch, but not implemented\r\n");
	}
#endif /* MACHINE_FIREBEE */

	vector &= 0x3fc;	/* mask out vector number */

	debug_printf("vector number = 0x%x\r\n", vector);

	vector += rt_vbr;	/* add vector base */
	

}

static void __attribute__((interrupt)) reset_exception_handler(void)
{
}

static void __attribute__((interrupt)) access_exception_handler(void)
{
}

static void __attribute__((interrupt)) irq1_exception_handler(void)
{
}

static void __attribute__((interrupt)) irq2_exception_handler(void)
{
}

static void __attribute__((interrupt)) irq3_exception_handler(void)
{
}

static void __attribute__((interrupt)) irq4_exception_handler(void)
{
}

static void __attribute__((interrupt)) irq5_exception_handler(void)
{
}

static void __attribute__((interrupt)) irq6_exception_handler(void)
{
}

static void __attribute__((interrupt)) irq7_exception_handler(void)
{
}

static void __attribute__((interrupt)) psc3_interrupt_handler(void)
{
}

static void __attribute__((interrupt)) gpt0_interrupt_handler(void)
{
}

extern void __attribute__((interrupt)) xhdi_sd_install(void);

void vec_init(void)
{
	exception_handler *VBR = (exception_handler *) &_RAMBAR0[0];
	extern uint32_t _SUP_SP[];	/* supervisor stack pointer from linker script */
	exception_handler *SUP_SP = (exception_handler *) &_SUP_SP[0];

	extern uint32_t rt_mod;
	extern uint32_t rt_ssp;
	extern uint32_t rt_usp;
	extern uint32_t rt_vbr;
	int i;

	rt_mod = -1;
	rt_ssp = 0;
	rt_usp = 0;
	rt_vbr = 0;

	set_vbr((uint32_t) VBR);

	/*
	 * set exception vectors
	 */
	for (i = 0; i < 256; i++)
	{
		VBR[i] = std_exception_handler;
	}

	VBR[0] = SUP_SP;

	VBR[1] = reset_exception_handler;
	VBR[2] = access_exception_handler;

#if MACHINE_FIREBEE		/* DIP switch only on FireBee */
	if (DIP_SWITCH & (1 << 7))
	{
		/* TODO: protect mode */
		return;
	}
#endif /* MACHINE_FIREBEE */

	VBR[0X80] = xhdi_sd_install;	/* trap #0 exception handler for BaS driver vectors */


#if MACHINE_FIREBEE
	/*
	 * ACP interrupts 1-7 (generated by the FPGA on the FireBee)
	 */
 	VBR[0X104] = irq1_exception_handler;
	VBR[0x108] = irq2_exception_handler;
	VBR[0x10c] = irq3_exception_handler;
	VBR[0x110] = irq4_exception_handler;
	VBR[0x114] = irq5_exception_handler;
	VBR[0x118] = irq6_exception_handler;
	VBR[0x11c] = irq7_exception_handler;

	/*
	 * install PSC vectors (used for PIC communication on the FireBee
	 */
	VBR[INT_SOURCE_PSC3 + 64] = psc3_interrupt_handler;

	/*
	 * install timer vector (used for video page copy on the FireBee
	 */
	VBR[INT_SOURCE_GPT0 + 64] = gpt0_interrupt_handler;
#endif /* MACHINE_FIREBEE */
}

