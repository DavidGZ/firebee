/*
 * exceptions.c
 *
 * This file is part of BaS_gcc.
 *
 * BaS_gcc is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * BaS_gcc is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BaS_gcc.  If not, see <http://www.gnu.org/licenses/>.
 *
 * derived from original BaS assembler sources:
 * Copyright 2010 - 2012 F. Aschwanden
 * Copyright 2013        M. Froeschle
 */

#include <stdint.h>
#include "bas_printf.h"
#include "bas_string.h"

#if MACHINE_FIREBEE
#include "firebee.h"
#elif MACHINE_M5484LITE
#include "m5484l.h"
#endif /* MACHINE_FIREBEE */


#define DEBUG_EXC
#ifdef DEBUG_EXC
#define debug_printf(format, arg...) do { xprintf("DEBUG: " format "\r\n", ##arg); } while (0)
#else
#define debug_printf(format, arg...) do { ; } while (0)
#endif /* DEBUG_EXC */

inline uint32_t set_vbr(uint32_t value)
{
	extern uint32_t rt_vbr;
	uint32_t ret = rt_vbr;

	__asm__ __volatile__(
		"movec		%[value],VBR\n\t"
		: /* no output */
		: [value] "r" (value)
		: /* no clobber */
	);
	rt_vbr = value;

	return ret;
}

void __attribute__((interrupt)) std_exception_handler()
{
}

void __attribute__((interrupt)) reset_exception_handler()
{
}

void __attribute__((interrupt)) access_exception_handler()
{
}

void __attribute__((interrupt)) irq1_exception_handler()
{
}

void __attribute__((interrupt)) irq2_exception_handler()
{
}

void __attribute__((interrupt)) irq3_exception_handler()
{
}

void __attribute__((interrupt)) irq4_exception_handler()
{
}

void __attribute__((interrupt)) irq5_exception_handler()
{
}

void __attribute__((interrupt)) irq6_exception_handler()
{
}

void __attribute__((interrupt)) irq7_exception_handler()
{
}

void vec_init(void)
{
	extern uint32_t _RAMBAR0[];	/* defined in linker script */
	uint32_t *VBR = &_RAMBAR0[0];
	extern uint32_t rt_mod;
	extern uint32_t rt_ssp;
	extern uint32_t rt_usp;
	extern uint32_t rt_vbr;
	int i;

	rt_mod = -1;
	rt_ssp = 0;
	rt_usp = 0;
	rt_vbr = 0;

	set_vbr((uint32_t) VBR);

	/*
	 * set exception vectors
	 */
	for (i = 0; i < 256; i++)
	{
		VBR[i] = std_exception_handler;
	}

	VBR[0] = __SUP_SP;

	VBR[1] = reset_exception_handler;
	VBR[2] = access_exception_handler;

#if MACHINE_FIREBEE		/* DIP switch only on FireBee */
	if (DIP_SWITCH & (1 << 7))
	{
		/* TODO: protect mode */
		return;
	}
#endif /* MACHINE_FIREBEE */

	VBR[0X80] = xhdi_install;	/* trap #0 exception handler for BaS driver vectors */


#if MACHINE_FIREBEE
	/*
	 * ACP interrupts 1-7 (generated by the FPGA on the FireBee)
	 */
 	VBR[0X104] = (uint32_t) irq1_exception_handler;
	VBR[0x108] = (uint32_t) irq2_exception_handler;
	VBR[0x10c] = (uint32_t) irq3_exception_handler;
	VBR[0x110] = (uint32_t) irq4_exception_handler;
	VBR[0x114] = (uint32_t) irq5_exception_handler;
	VBR[0x118] = (uint32_t) irq6_exception_handler;
	VBR[0x11c] = (uint32_t) irq7_exception_handler;

	/*
	 * install PSC vectors (used for PIC communication on the FireBee
	 */
	VBR[INT_SOURCE_PSC3 + 64] = psc3_interrupt_handler;

	/*
	 * install timer vector (used for video page copy on the FireBee
	 */
	VBR[INT_SOURCE_GPT0 + 64] = gpt0_interrupt_handler;
#endif /* MACHINE_FIREBEE */
}

