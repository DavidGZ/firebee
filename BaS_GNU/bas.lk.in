MEMORY {
   flash (RX)  : ORIGIN = TARGET_ADDRESS, LENGTH = 0x00200000
   ram (WX) : ORIGIN = 0x1FE00000, LENGTH = 0x00100000		/* target to copy BaS to */
}

SECTIONS {
	_Bas_base = 0x1FE00000;
	_tos_base = 0x00e00000;
	 
	/* Init CS0 (BootFLASH @ E000_0000 - E07F_FFFF 8Mbytes) */
	___BOOT_FLASH           = TARGET_ADDRESS;
 	___BOOT_FLASH_SIZE      = 0x00800000;
	/* SDRAM Initialization @ 0000_0000 - 1FFF_FFFF 512Mbytes */
 	___SDRAM                = 0x00000000;
 	___SDRAM_SIZE           = 0x20000000;

	/* Flash components */
	__FIRETOS               = 0xe0400000;
	__EMUTOS                = 0xe0600000;
	__EMUTOS_SIZE           = 0x00100000;

	/* VIDEO RAM BASIS */
	__VRAM                  = 0x60000000;

	/* Memory mapped registers */
 	__MBAR                  = 0xFF000000;
 	__MMUBAR                = 0xFF040000;

	/*
	 * 4KB on-chip Core SRAM0: -> exception table and exception stack
	 */
 	__RAMBAR0               = 0xFF100000;
 	__RAMBAR0_SIZE          = 0x00001000;

 	__SUP_SP = __RAMBAR0 + __RAMBAR0_SIZE - 4;

	/* 4KB on-chip Core SRAM1: -> modified code */
 	__RAMBAR1               = 0xFF101000;
 	__RAMBAR1_SIZE          = 0x00001000;

	/* system variables */
	
	/* RAMBAR0 0 to 0x7FF -> exception vectors */
	_rt_mod    = __RAMBAR0 + 0x800;
	_rt_ssp    = __RAMBAR0 + 0x804;
	_rt_usp    = __RAMBAR0 + 0x808;
	_rt_vbr    = __RAMBAR0 + 0x80C;  	/* (8)01 */
	_rt_cacr   = __RAMBAR0 + 0x810;   	/* 002 */
	_rt_asid   = __RAMBAR0 + 0x814;   	/* 003 */
	_rt_acr0   = __RAMBAR0 + 0x818;   	/* 004 */
	_rt_acr1   = __RAMBAR0 + 0x81c;   	/* 005 */
	_rt_acr2   = __RAMBAR0 + 0x820;   	/* 006 */
	_rt_acr3   = __RAMBAR0 + 0x824;   	/* 007 */
	_rt_mmubar = __RAMBAR0 + 0x828;		/* 008 */
	_rt_sr     = __RAMBAR0 + 0x82c;
	_d0_save   = __RAMBAR0 + 0x830;
	_a7_save   = __RAMBAR0 + 0x834;
	_video_tlb = __RAMBAR0 + 0x838;
	_video_sbt = __RAMBAR0 + 0x83C;
	_rt_mbar   = __RAMBAR0 + 0x844;   	/* (c)0f */

	/* 32KB on-chip System SRAM */
 	__SYS_SRAM              = 0xFF010000;
	__SYS_SRAM_SIZE         = 0x00008000;

	.text ___BOOT_FLASH :
	{
		objs/startcf.o(.text) /* this one is the entry point so it must be the first */
		objs/sysinit.o(.text)
		objs/init_fpga.o(.text)
#if (FORMAT == elf32-m68k)
		*(.rodata)
		*(.rodata.*)
		. = ALIGN(4);
#endif
	} > flash

	.bas _Bas_base : AT (ADDR(.text) + SIZEOF(.text)) ALIGN(1024)
	{
		objs/BaS.o(.text)
		/* put other routines into the same segment (RAM) as BaS.o */ 
		objs/sd_card_asm.o(.text)
		objs/bas_printf.o(.text)
		objs/printf_helper.o(.text)
		objs/cache.o(.text)
		objs/sd_card.o(.text)
		objs/mmu.o(.text)
		objs/exceptions.o(.text)
		objs/supervisor.o(.text)
		objs/ewf.o(.text)
		objs/illegal_instruction.o(.text)
		*(.data)
		*(.bss)	
		. = ALIGN(4);

		_bas_end = .;
	} > ram

	__BAS_LMA = LOADADDR(.bas);
	__BAS_VMA = ADDR(.bas);
	__BAS_SIZE = SIZEOF(.bas);

	/* The following labels are BaS routines in the flash,
	 * before they are copied to their final location in the RAM.
	 * This is to allow using them before and after the actual copy.
	 * Hence they must contain only pc-relative code (compiled with -mpcrel).
	 */
#define BAS_LABEL_LMA(x) ((x) + (__BAS_LMA - __BAS_VMA))
	_xprintf_before_copy = BAS_LABEL_LMA(_xprintf);
	_display_progress_before_copy = BAS_LABEL_LMA(_display_progress);
	_flush_and_invalidate_caches_before_copy = BAS_LABEL_LMA(_flush_and_invalidate_caches);
}
