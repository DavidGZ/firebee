MEMORY {
   flash (RX)  : ORIGIN = TARGET_ADDRESS, LENGTH = 0x00200000
   ram (WX) : ORIGIN = 0x1FE00000, LENGTH = 0x00100000		/* target to copy BaS to */
}

SECTIONS {
	_Bas_base = ABSOLUTE(0x1FE00000);
	_tos_base = ABSOLUTE(0xe00000);
	 
	/* Init CS0 (BootFLASH @ E000_0000 - E07F_FFFF 8Mbytes) */
	___BOOT_FLASH           = ABSOLUTE(TARGET_ADDRESS);
 	___BOOT_FLASH_SIZE      = ABSOLUTE(0x00800000);
	/* SDRAM Initialization @ 0000_0000 - 1FFF_FFFF 512Mbytes */
 	___SDRAM                = ABSOLUTE(0x00000000);
 	___SDRAM_SIZE           = ABSOLUTE(0x20000000);

	/* Flash components */
	__FIRETOS               = ABSOLUTE(0xe0400000);
	__EMUTOS                = ABSOLUTE(0xe0600000);
	__EMUTOS_SIZE           = ABSOLUTE(0x00100000);

	/* VIDEO RAM BASIS */
	__VRAM                = ABSOLUTE(0x60000000);

	/* Memory mapped registers */
 	__MBAR                 = ABSOLUTE(0xFF000000);
 	__MMUBAR               = ABSOLUTE(0xFF040000);

	/*
	 * 4KB on-chip Core SRAM0: -> exception table and exception stack
	 */
 	__RAMBAR0              = ABSOLUTE(0xFF100000);
 	__RAMBAR0_SIZE         = ABSOLUTE(0x00001000);

 	__SUP_SP = ABSOLUTE(__RAMBAR0 + __RAMBAR0_SIZE - 4);

	/* 4KB on-chip Core SRAM1: -> modified code */
 	__RAMBAR1              = ABSOLUTE(0xFF101000);
 	__RAMBAR1_SIZE         = ABSOLUTE(0x00001000);

	/* system variables */
	
	/* RAMBAR0 0 to 0x7FF -> exception vectors */
	_rt_mod    = __RAMBAR0 + 0x800;
	_rt_ssp    = __RAMBAR0 + 0x804;
	_rt_usp    = __RAMBAR0 + 0x808;
	_rt_vbr    = __RAMBAR0 + 0x80C;  	/* (8)01 */
	_rt_cacr   = __RAMBAR0 + 0x810;   	/* 002 */
	_rt_asid   = __RAMBAR0 + 0x814;   	/* 003 */
	_rt_acr0   = __RAMBAR0 + 0x818;   	/* 004 */
	_rt_acr1   = __RAMBAR0 + 0x81c;   	/* 005 */
	_rt_acr2   = __RAMBAR0 + 0x820;   	/* 006 */
	_rt_acr3   = __RAMBAR0 + 0x824;   	/* 007 */
	_rt_mmubar = __RAMBAR0 + 0x828;		/* 008 */
	_rt_sr     = __RAMBAR0 + 0x82c;
	_d0_save   = __RAMBAR0 + 0x830;
	_a7_save   = __RAMBAR0 + 0x834;
	_video_tlb = __RAMBAR0 + 0x838;
	_video_sbt = __RAMBAR0 + 0x83C;
	_rt_mbar   = __RAMBAR0 + 0x844;   	/* (c)0f */

	/* 32KB on-chip System SRAM */
 	__SYS_SRAM             = ABSOLUTE(0xFF010000);
	__SYS_SRAM_SIZE        = ABSOLUTE(0x00008000);

	.text ___BOOT_FLASH :
	{
		objs/startcf.o(.text) /* this one is the entry point so it must be the first */
		objs/sysinit.o(.text)
		objs/init_fpga.o(.text)
#if (FORMAT == elf32-m68k)
		*(.rodata)
		*(.rodata.*)
		. = ALIGN(4);
#endif
	} > flash

	.bas _Bas_base : AT (ADDR(.text) + SIZEOF(.text))
	{
		objs/BaS.o(.text)
		/* put other routines into the same segment (RAM) as BaS.o */ 
		objs/sd_card_asm.o(.text)
		objs/bas_printf.o(.text)
		objs/printf_helper.o(.text)
		objs/cache.o(.text)
		objs/sd_card.o(.text)
		objs/mmu.o(.text)
		objs/exceptions.o(.text)
		objs/supervisor.o(.text)
		objs/ewf.o(.text)
		objs/illegal_instruction.o(.text)
		*(.data)
		*(.bss)	
		. = ALIGN(4);

		_bas_end = ABSOLUTE(.);
	} > ram

	__BAS_LMA = LOADADDR(.bas);
	__BAS_VMA = ADDR(.bas);
	__BAS_SIZE = SIZEOF(.bas);

	/* The following labels are BaS routines in the flash,
	 * before they are copied to their final location in the RAM.
	 * This is to allow using them before and after the actual copy.
	 * Hence they must contain only pc-relative code (compiled with -mpcrel).
	 */
#define BAS_LABEL_LMA(x) ((x) + (ABSOLUTE(__BAS_LMA) - ABSOLUTE(__BAS_VMA)))
	_xprintf_before_copy = BAS_LABEL_LMA(_xprintf);
	_display_progress_before_copy = BAS_LABEL_LMA(_display_progress);
	_flush_and_invalidate_caches_before_copy = BAS_LABEL_LMA(_flush_and_invalidate_caches);
}
